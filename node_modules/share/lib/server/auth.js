var hat, types;

hat = require('hat');

types = require('../types');

module.exports = function(model, options) {
  var Client, auth;
  auth = options.auth || function(client, action) {
    var _ref;
    if ((_ref = action.type) === 'connect' || _ref === 'read' || _ref === 'create' || _ref === 'update') {
      return action.accept();
    } else {
      return action.reject();
    }
  };
  Client = (function() {

    function Client(data) {
      this.id = hat();
      this.connectTime = new Date;
      this.headers = data.headers;
      this.remoteAddress = data.remoteAddress;
      this.listeners = {};
    }

    Client.prototype.doAuth = function(actionData, name, userCallback, acceptCallback) {
      var action, responded;
      action = actionData || {};
      action.name = name;
      action.type = (function() {
        switch (name) {
          case 'connect':
            return 'connect';
          case 'create':
            return 'create';
          case 'get snapshot':
          case 'get ops':
          case 'open':
            return 'read';
          case 'submit op':
            return 'update';
          case 'delete':
            return 'delete';
          default:
            throw new Error("Invalid action name " + name);
        }
      })();
      responded = false;
      action.reject = function() {
        if (responded) throw new Error('Multiple accept/reject calls made');
        responded = true;
        return userCallback('forbidden', null);
      };
      action.accept = function() {
        if (responded) throw new Error('Multiple accept/reject calls made');
        responded = true;
        return acceptCallback();
      };
      return auth(this, action);
    };

    Client.prototype.disconnect = function() {
      var docName, listener, _ref, _results;
      _ref = this.listeners;
      _results = [];
      for (docName in _ref) {
        listener = _ref[docName];
        _results.push(model.removeListener(docName, listener));
      }
      return _results;
    };

    Client.prototype.getOps = function(docName, start, end, callback) {
      return this.doAuth({
        docName: docName,
        start: start,
        end: end
      }, 'get ops', callback, function() {
        return model.getOps(docName, start, end, callback);
      });
    };

    Client.prototype.getSnapshot = function(docName, callback) {
      return this.doAuth({
        docName: docName
      }, 'get snapshot', callback, function() {
        return model.getSnapshot(docName, callback);
      });
    };

    Client.prototype.create = function(docName, type, meta, callback) {
      var _this = this;
      if (typeof type === 'string') type = types[type];
      return this.doAuth({
        docName: docName,
        docType: type,
        meta: meta
      }, 'create', callback, function() {
        return model.create(docName, type, meta, callback);
      });
    };

    Client.prototype.submitOp = function(docName, opData, callback) {
      var _this = this;
      opData.meta || (opData.meta = {});
      opData.meta.source = this.id;
      return this.doAuth({
        docName: docName,
        op: opData.op,
        v: opData.v,
        meta: opData.meta
      }, 'submit op', callback, function() {
        return model.applyOp(docName, opData, callback);
      });
    };

    Client.prototype["delete"] = function(docName, callback) {
      var _this = this;
      return this.doAuth({
        docName: docName
      }, 'delete', callback, function() {
        return model["delete"](docName, callback);
      });
    };

    Client.prototype.listen = function(docName, version, listener, callback) {
      var authOps,
        _this = this;
      authOps = version != null ? function(c) {
        return _this.doAuth({
          docName: docName,
          start: version,
          end: null
        }, 'get ops', callback, c);
      } : function(c) {
        return c();
      };
      return authOps(function() {
        return _this.doAuth({
          docName: docName,
          v: version != null ? version : void 0
        }, 'open', callback, function() {
          if (_this.listeners[docName]) {
            return typeof callback === "function" ? callback('Document is already open') : void 0;
          }
          _this.listeners[docName] = listener;
          return model.listen(docName, version, listener, function(error, v) {
            if (error) delete _this.listeners[docName];
            return typeof callback === "function" ? callback(error, v) : void 0;
          });
        });
      });
    };

    Client.prototype.removeListener = function(docName) {
      if (!this.listeners[docName]) throw new Error('Document is not open');
      model.removeListener(docName, this.listeners[docName]);
      return delete this.listeners[docName];
    };

    return Client;

  })();
  return function(data, callback) {
    var client;
    client = new Client(data);
    return client.doAuth(null, 'connect', callback, function() {
      return callback(null, client);
    });
  };
};
